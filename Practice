#1)
# Compare version #'s and return true if version A > version B
#
# Write a function that takes two strings, representing version numbers
# and returns a boolean indicating whether the first string is a later
# version than the second. For the purposes of this problem, assume that
# the input strings will consist only of periods and decimal digits.
# e.g. '1' < '2', '1.3' > '1.1', '2.12' > '2.9', '2.1.1' > '2.1'
s1 = '2'
s2 = '1.3'
s3 ='2.12'
s4 = '2.9'
s5 = '2.1.1'
s6 = '2'
def latest_version(str1, str2):
    n = 0
    if n < 0:
        return False
    elif str1 > str2:
        n += 1
    elif str1 < str2:
        n -= 1
    elif str1 == str2:
        return True
    return n == 1
print(latest_version(s1, s2))
print(latest_version(s3, s4)) #This should return True but returns false
print(latest_version(s5, s6))
print(latest_version(s1, s6))
#2)
# Detect balanced parens in a string with parens and other chars
#
# Write a function that is given a string and returns a boolean indicating
# whether that string has balanced parentheses. The string may have
# characters other than parentheses, and should be ignored. e.g. 'x()' is
# balanced. '((y(' is not, 'a(b())' is balanced, ')()(' is not.

#'a(b(c)c)d'

#function(string):
#   i = 0
#   loop (string as char):
#       if i < 0:
#           return False
#       if char == '(':
#           i += 1
#       if char == '):
#           i -= 1
#
#   return i == 0

#print("Expected True got: " + ('True' if is_balanced('a(b(c)dc)') else 'False') + "\n")
#print("Expected True got: " + ('True' if is_balanced('(())') else 'False') + "\n")

#3)
# Detect a palindrome. ignoring case and non-alphabetic characters.
#
# Write a function that is given a string and returns a boolean indicating
# whether the string is a palindrome *ignoring* case and punctuation. Only 
# alphabetic letters should be considered in deciding whether the string is a
# palindrome. So, for example, 'aba' is a palindrome, but so is '..a$$b(a'.
# 'damn, I'm Adam' is a palindrome. 'dadax' is not.




